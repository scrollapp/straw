"use strict";class Fila{static setup(backend,sep,cwd,temp){this.backend=backend;this._sep=sep||"/";this._cwd=cwd;this._temporary=temp}static backend;static get sep(){return this._sep}static _sep="/";static get cwd(){if(typeof this._cwd==="string")return this._cwd=new Fila(this._cwd);return this._cwd}static _cwd="";static get temporary(){if(typeof this._temporary==="string")return this._temporary=new Fila(this._temporary);return this._temporary}static _temporary="";static from(via){return typeof via==="string"?new Fila(via):via}constructor(...components){this.components=components;const backend=Fila.backend;if(!backend)throw new Error("Fila backend not set.");components=components.filter((s=>!!s));if(components.join("")==="/")return new backend(["/"]);if(components.length===0||components[0].startsWith("."))components.unshift(Fila.cwd.path);for(let i=-1;++i<components.length;)components.splice(i,1,...components[i].split(Fila.sep));components=components.filter((s=>!!s));components=Fila.normalize(components.join(Fila.sep)).split(Fila.sep);Object.assign(this,backend)}components;not(){throw new Error("This method isn't implemented.")}readText(){return this.not()}readBinary(){return this.not()}readDirectory(){return this.not()}writeText(text,options){return this.not()}writeBinary(buffer){return this.not()}writeDirectory(){return this.not()}writeSymlink(at){return this.not()}delete(){return this.not()}move(target){return this.not()}copy(target){return this.not()}watch(a,b){const recursive=a==="recursive";const callbackFn=b||a;return this.watchProtected(recursive,callbackFn)}watchProtected(recursive,callbackFn){return this.not()}rename(newName){return this.not()}exists(){return this.not()}getSize(){return this.not()}getModifiedTicks(){return this.not()}getCreatedTicks(){return this.not()}getAccessedTicks(){return this.not()}isDirectory(){return this.not()}async getDirectory(){if(await this.isDirectory())return this;return new Fila(...this.up().components)}get name(){return this.components.at(-1)||""}get extension(){const name=this.name;const lastDot=name.lastIndexOf(".");return lastDot<0?"":name.slice(lastDot)}get path(){return Fila.sep+Fila.join(...this.components)}up(count=1){if(this.components.length<2)return this;const parentComponents=this.components.slice(0,-count);return parentComponents.length>0?new Fila(...parentComponents):new Fila("/")}async upscan(relativeFileName){let ancestry=this;do{const maybe=ancestry.down(relativeFileName);if(await maybe.exists())return maybe;if(ancestry.components.length===1)break;ancestry=ancestry.up()}while(ancestry.components.length>0);return null}down(...additionalComponents){return new Fila(...this.components,...additionalComponents)}}(function(Fila){function join(...args){if(args.length===0)return".";let joined;for(let i=0;i<args.length;++i){let arg=args[i];if(arg.length>0){if(joined===undefined)joined=arg;else joined+="/"+arg}}if(joined===undefined)return".";return normalize(joined)}Fila.join=join;function normalize(path){if(path.length===0)return".";const isAbsolute=path.charCodeAt(0)===47;const trailingSeparator=path.charCodeAt(path.length-1)===47;path=normalizeStringPosix(path,!isAbsolute);if(path.length===0&&!isAbsolute)path=".";if(path.length>0&&trailingSeparator)path+=Fila.sep;if(isAbsolute)return Fila.sep+path;return path}Fila.normalize=normalize;function normalizeStringPosix(path,allowAboveRoot){let res="";let lastSegmentLength=0;let lastSlash=-1;let dots=0;let code;for(let i=0;i<=path.length;++i){if(i<path.length)code=path.charCodeAt(i);else if(code===47)break;else code=47;if(code===47){if(lastSlash===i-1||dots===1){}else if(lastSlash!==i-1&&dots===2){if(res.length<2||lastSegmentLength!==2||res.charCodeAt(res.length-1)!==46||res.charCodeAt(res.length-2)!==46){if(res.length>2){let lastSlashIndex=res.lastIndexOf(Fila.sep);if(lastSlashIndex!==res.length-1){if(lastSlashIndex===-1){res="";lastSegmentLength=0}else{res=res.slice(0,lastSlashIndex);lastSegmentLength=res.length-1-res.lastIndexOf(Fila.sep)}lastSlash=i;dots=0;continue}}else if(res.length===2||res.length===1){res="";lastSegmentLength=0;lastSlash=i;dots=0;continue}}if(allowAboveRoot){if(res.length>0)res+="/..";else res="..";lastSegmentLength=2}}else{if(res.length>0)res+=Fila.sep+path.slice(lastSlash+1,i);else res=path.slice(lastSlash+1,i);lastSegmentLength=i-lastSlash-1}lastSlash=i;dots=0}else if(code===46&&dots!==-1){++dots}else dots=-1}return res}function relative(from,to){if(from===to)return"";from=posix.resolve(from instanceof Fila?from.path:from);to=posix.resolve(to instanceof Fila?to.path:to);if(from===to)return"";var fromStart=1;for(;fromStart<from.length;++fromStart)if(from.charCodeAt(fromStart)!==47)break;var fromEnd=from.length;var fromLen=fromEnd-fromStart;var toStart=1;for(;toStart<to.length;++toStart)if(to.charCodeAt(toStart)!==47)break;var toEnd=to.length;var toLen=toEnd-toStart;var length=fromLen<toLen?fromLen:toLen;var lastCommonSep=-1;var i=0;for(;i<=length;++i){if(i===length){if(toLen>length){if(to.charCodeAt(toStart+i)===47){return to.slice(toStart+i+1)}else if(i===0){return to.slice(toStart+i)}}else if(fromLen>length){if(from.charCodeAt(fromStart+i)===47){lastCommonSep=i}else if(i===0){lastCommonSep=0}}break}var fromCode=from.charCodeAt(fromStart+i);var toCode=to.charCodeAt(toStart+i);if(fromCode!==toCode)break;else if(fromCode===47)lastCommonSep=i}var out="";for(i=fromStart+lastCommonSep+1;i<=fromEnd;++i){if(i===fromEnd||from.charCodeAt(i)===47){if(out.length===0)out+="..";else out+="/.."}}if(out.length>0)return out+to.slice(toStart+lastCommonSep);toStart+=lastCommonSep;if(to.charCodeAt(toStart)===47)++toStart;return to.slice(toStart)}Fila.relative=relative;const posix={resolve(...args){var resolvedPath="";var resolvedAbsolute=false;var cwd;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path;if(i>=0)path=args[i];else{if(cwd===undefined&&typeof process==="object")cwd=process.cwd();path=cwd}if(path.length===0)continue;resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charCodeAt(0)===47}resolvedPath=normalizeStringPosix(resolvedPath,!resolvedAbsolute);if(resolvedAbsolute){if(resolvedPath.length>0)return"/"+resolvedPath;else return"/"}else if(resolvedPath.length>0)return resolvedPath;return"."}};let Char;(function(Char){Char[Char["dot"]=46]="dot";Char[Char["slash"]=47]="slash"})(Char||(Char={}));let Event;(function(Event){Event["create"]="create";Event["modify"]="modify";Event["delete"]="delete"})(Event=Fila.Event||(Fila.Event={}))})(Fila||(Fila={}));typeof module==="object"&&Object.assign(module.exports,{Fila:Fila});var Cover;(function(Cover){async function coverFila(){const path=globalThis.__TAURI__.path;const cwdString=await path.appDataDir();const cwd=new Fila(cwdString);debugger;const testFile=cwd.down("file.txt");await testFile.writeText(Date.now().toString());const text=await testFile.readText();console.log(text);const dir=cwd.down("dir");await dir.writeDirectory();await dir.down("a.txt").writeText(Date.now().toString());await dir.down("b.txt").writeText(Date.now().toString());await dir.down("c.txt").writeText(Date.now().toString());await dir.down("a").writeDirectory();await dir.down("b").writeDirectory();await dir.down("c").writeDirectory();{const file=dir.down("a.txt");const ac=await file.getAccessedTicks();const cr=await file.getCreatedTicks();const mo=await file.getModifiedTicks();const sz=await file.getSize();const dr=await file.getDirectory();debugger}const contents=await dir.readDirectory();for(const entry of contents)console.log(entry.path);const unwatch=dir.watch(((ev,fila)=>{console.log(ev+" - "+fila.path);unwatch}))}Cover.coverFila=coverFila;async function coverFilaTauri(){const fila=new Fila("FilaTauri","+sample");fila.watch(((ev,fila)=>{console.log(ev+": "+fila.path)}))}Cover.coverFilaTauri=coverFilaTauri;0&&"__TAURI__"in globalThis&&setTimeout((()=>{document.body.addEventListener("click",coverFila,true)}))})(Cover||(Cover={}));if(typeof module==="object")Object.assign(module.exports,{Cover:Cover});(()=>{if(typeof CAPACITOR==="undefined")Object.assign(globalThis,{CAPACITOR:typeof window!=="undefined"&&typeof window.Capacitor!=="undefined"});if(!CAPACITOR)return;class FilaCapacitor extends Fila{get fs(){const g=globalThis;const fs=g.Capacitor?.Plugins?.Filesystem;if(!fs)throw new Error("Filesystem plugin not added to Capacitor.");return fs}get path(){return Fila.join(...this.components)}async readText(){const result=await this.fs.readFile({...this.getDefaultOptions(),encoding:"utf8"});return result.data}async readBinary(){const result=await this.fs.readFile({...this.getDefaultOptions(),encoding:"ascii"});const blob=result.data;const buffer=await new Response(blob).arrayBuffer();return new Uint8Array(buffer)}async readDirectory(){const result=await this.fs.readdir(this.getDefaultOptions());const filas=[];for(const file of result.files)if(file.name!==".DS_Store")filas.push(new Fila(this.path,file.name||""));return filas}async writeText(text,options){try{const up=this.up();if(!await up.exists())await up.writeDirectory();const writeOptions={...this.getDefaultOptions(),data:text,encoding:"utf8"};if(options?.append)await this.fs.appendFile(writeOptions);else await this.fs.writeFile(writeOptions)}catch(e){console.error("Write failed to path: "+this.path);debugger}}async writeBinary(arrayBuffer){await this.up().writeDirectory();const data=await this.arrayBufferToBase64(arrayBuffer);await this.fs.writeFile({...this.getDefaultOptions(),data:data,encoding:"ascii"})}arrayBufferToBase64(buffer){return new Promise((r=>{const blob=new Blob([buffer],{type:"application/octet-binary"});const reader=new FileReader;reader.onload=ev=>{const dataUrl=ev.target?.result||"";const slice=dataUrl.slice(dataUrl.indexOf(`,`)+1);r(slice)};reader.readAsDataURL(blob)}))}async writeDirectory(){await this.fs.mkdir({...this.getDefaultOptions(),recursive:true})}async writeSymlink(at){throw new Error("Not implemented")}async delete(){if(await this.isDirectory()){return new Promise((async r=>{await this.fs.rmdir({...this.getDefaultOptions(),recursive:true});r()}))}await this.fs.deleteFile(this.getDefaultOptions())}async move(target){throw new Error("Not implemented.")}async copy(target){const fromOptions=this.getDefaultOptions();const toOptions=this.getDefaultOptions(target.path);await this.fs.copy({from:fromOptions.path,directory:fromOptions.directory,to:toOptions.path,toDirectory:toOptions.directory})}async rename(newName){const target=this.up().down(newName).path;const fromOptions=this.getDefaultOptions();const toOptions=this.getDefaultOptions(target);await this.fs.rename({from:this.path,directory:fromOptions.directory,to:target,toDirectory:toOptions.directory})}watchProtected(recursive,callbackFn){throw new Error("Not implemented")}async exists(){return!!await this.getStat()}async getSize(){return(await this.getStat())?.size||0}async getModifiedTicks(){return(await this.getStat())?.mtime||0}async getCreatedTicks(){return(await this.getStat())?.ctime||0}async getAccessedTicks(){return 0}async isDirectory(){return(await this.getStat())?.type==="directory"}async getStat(){try{return await this.fs.stat(this.getDefaultOptions())}catch(e){return null}}getDefaultOptions(targetPath=this.path){const slash=targetPath.indexOf("/");let path="";let directory="";if(slash<0){path=targetPath;directory="CACHE"}else{path=targetPath.slice(slash+1);directory=targetPath.slice(0,slash)}const result={path:path,directory:directory};return result}}let Directory;(function(Directory){Directory["cache"]="CACHE";Directory["data"]="DATA";Directory["documents"]="DOCUMENTS";Directory["external"]="EXTERNAL";Directory["externalStorage"]="EXTERNAL_STORAGE";Directory["library"]="LIBRARY"})(Directory||(Directory={}));const cwd="DATA";const tmp="CACHE";const sep="/";Fila.setup(FilaCapacitor,sep,cwd,tmp)})();var Cover;(function(Cover){function coverFilaNode(){const fila=new Fila(process.cwd(),"FilaNode","+sample");fila.watch(((ev,fila)=>{console.log(ev+": "+fila.path)}));process.stdin.resume()}Cover.coverFilaNode=coverFilaNode})(Cover||(Cover={}));typeof module==="object"&&Object.assign(module.exports,{Cover:Cover});(()=>{if(typeof NODE==="undefined")Object.assign(globalThis,{NODE:typeof process+typeof require==="objectfunction"});if(!NODE)return;class FilaNode extends Fila{fs=require("fs");async readText(){return await this.fs.promises.readFile(this.path,"utf8")}async readBinary(){return await this.fs.promises.readFile(this.path)}async readDirectory(){const fileNames=await this.fs.promises.readdir(this.path);const filas=[];for(const fileName of fileNames)if(fileName!==".DS_Store")filas.push(new Fila(...this.components,fileName));return filas}async writeText(text,options){await this.up().writeDirectory();if(options?.append)await this.fs.promises.appendFile(this.path,text);else await this.fs.promises.writeFile(this.path,text)}async writeBinary(arrayBuffer){await this.up().writeDirectory();const buffer=Buffer.from(arrayBuffer);await this.fs.promises.writeFile(this.path,buffer)}async writeDirectory(){if(!this.fs.existsSync(this.path))await this.fs.promises.mkdir(this.path,{recursive:true})}async writeSymlink(at){return new Promise((r=>{this.fs.symlink(at.path,this.path,(()=>{r()}))}))}async delete(){if(await this.isDirectory()){return new Promise((resolve=>{this.fs.rmdir(this.path,{recursive:true},(error=>{resolve(error||void 0)}))}))}await this.fs.promises.unlink(this.path)}move(target){return new Promise((resolve=>{this.fs.rename(this.path,target.path,(()=>resolve()))}))}copy(target){return new Promise((async resolve=>{if(await this.isDirectory()){this.fs.cp(this.path,target.path,{recursive:true,force:true},(()=>resolve()))}else{const dir=target.up();if(!await dir.exists())await new Promise((r=>this.fs.mkdir(dir.path,{recursive:true},r)));this.fs.copyFile(this.path,target.path,(()=>resolve()))}}))}watchProtected(recursive,callbackFn){const watcher=FilaNode.chokidar.watch(this.path);watcher.on("ready",(()=>{watcher.on("all",((evName,path)=>{if(path.endsWith("/.DS_Store"))return;let ev;if(evName==="add")ev="create";else if(evName==="change")ev="modify";else if(evName==="unlink")ev="delete";if(ev)callbackFn(ev,new Fila(path))}))}));return()=>{watcher.removeAllListeners()}}static get chokidar(){return this._chokidar||(this._chokidar=require("chokidar"))}static _chokidar;rename(newName){return this.fs.promises.rename(this.path,this.up().down(newName).path)}async exists(){return new Promise((r=>{this.fs.stat(this.path,(error=>{r(!error)}))}))}async getSize(){const stats=await this.getStats();return stats?.size||0}async getModifiedTicks(){const stats=await this.getStats();return stats?.mtimeMs||0}async getCreatedTicks(){const stats=await this.getStats();return stats?.birthtimeMs||0}async getAccessedTicks(){const stats=await this.getStats();return stats?.atimeMs||0}async isDirectory(){const stats=await this.getStats();return stats?.isDirectory()||false}async getStats(){return new Promise((r=>{this.fs.stat(this.path,((error,stats)=>{r(stats)}))}))}}const sep=require("path").sep;const cwd=process.cwd();const tmp=require("os").tmpdir();Fila.setup(FilaNode,sep,cwd,tmp)})();(()=>{if(typeof TAURI==="undefined")Object.assign(globalThis,{TAURI:typeof window!=="undefined"&&typeof globalThis.__TAURI__!=="undefined"});if(!TAURI)return;class FilaTauri extends Fila{fs=globalThis.__TAURI__.fs;readText(){return this.fs.readTextFile(this.path)}readBinary(){return this.fs.readBinaryFile(this.path)}async readDirectory(){const fileNames=await this.fs.readDir(this.path);const filas=[];for(const fileName of fileNames)if(fileName.name!==".DS_Store")filas.push(new Fila(this.path,fileName.name||""));return filas}async writeText(text,options){try{const up=this.up();if(!await up.exists())await up.writeDirectory();await this.fs.writeTextFile(this.path,text,{append:options?.append})}catch(e){debugger}}async writeBinary(arrayBuffer){await this.up().writeDirectory();await this.fs.writeBinaryFile(this.path,arrayBuffer)}async writeDirectory(){this.fs.createDir(this.path,{recursive:true})}async writeSymlink(at){return null}async delete(){if(await this.isDirectory()){return new Promise((async resolve=>{await this.fs.removeDir(this.path,{recursive:true});resolve()}))}await this.fs.removeFile(this.path)}move(target){return null}async copy(target){if(await target.isDirectory())throw"Copying directories is not implemented.";await this.fs.copyFile(this.path,target.path)}watchProtected(recursive,callbackFn){let un=null;(async()=>{un=await watchInternal(this.path,{},(async ev=>{if(!un)return;const payload=ev.payload.payload;if(typeof payload!=="string")return;const fila=new Fila(ev.payload.payload);if(ev.type==="NoticeWrite"||ev.type==="Write")callbackFn("modify",fila);else if(ev.type==="NoticeRemove"||ev.type==="Remove")callbackFn("delete",fila);else if(ev.type==="Create"||ev.type==="Rename")callbackFn("modify",fila)}))})();return()=>{if(un)un();else setTimeout((()=>un?.()),100)}}async rename(newName){return this.fs.renameFile(this.path,this.up().down(newName).path)}async exists(){return this.fs.exists(this.path)}async getSize(){return(await this.getMeta()).size}async getModifiedTicks(){return(await this.getMeta()).modifiedAt}async getCreatedTicks(){return(await this.getMeta()).createdAt}async getAccessedTicks(){return(await this.getMeta()).accessedAt}async isDirectory(){return(await this.getMeta()).isDir}async getMeta(){return this._meta||(this._meta=await getMetadata(this.path))}_meta=null}const t=globalThis.__TAURI__;const tauri=t.tauri;const wind=t.window;async function unwatch(id){await tauri.invoke("plugin:fs-watch|unwatch",{id:id})}async function watchInternal(paths,options,callbackFn){const opts={recursive:false,delayMs:2e3,...options};let watchPaths;if(typeof paths==="string")watchPaths=[paths];else watchPaths=paths;const id=window.crypto.getRandomValues(new Uint32Array(1))[0];await tauri.invoke("plugin:fs-watch|watch",{id:id,paths:watchPaths,options:opts});const unlisten=await wind.appWindow.listen(`watcher://raw-event/${id}`,(event=>{callbackFn(event)}));return async()=>{await unwatch(id);unlisten()}}async function watchImmediate(paths,options,callbackFn){const opts={recursive:false,...options,delayMs:null};const watchPaths=typeof paths==="string"?[paths]:paths;const id=window.crypto.getRandomValues(new Uint32Array(1))[0];await tauri.invoke("plugin:fs-watch|watch",{id:id,paths:watchPaths,options:opts});const unlisten=await wind.appWindow.listen(`watcher://raw-event/${id}`,(event=>{callbackFn(event)}));return async()=>{await unwatch(id);unlisten()}}function getMetadata(path){return tauri.invoke("plugin:fs-extra|metadata",{path:path})}{let path=null;try{path=globalThis.__TAURI__.path}catch(e){console.log("withGlobalTauri is not set");return}const sep=path?.sep||"/";const cwd="/";const tmp="/";Fila.setup(FilaTauri,sep,cwd,tmp);(async()=>{const tmp=await path.appCacheDir();Fila.setup(FilaTauri,sep,cwd,tmp)})()}})();var Cover;(function(Cover){async function coverFilaWeb(){const dir=new Fila("dir");dir.writeDirectory();const filaText=dir.down("file.txt");await filaText.writeText("yay!");const filaBinary=dir.down("file.bin");const buffer=new Uint8Array([0,1,2]);await filaBinary.writeBinary(buffer);const contents=await dir.readDirectory();for(const fila of contents)console.log(fila.path);await dir.delete();debugger}Cover.coverFilaWeb=coverFilaWeb;typeof module==="object"&&Object.assign(module.exports,{Cover:Cover})})(Cover||(Cover={}));(()=>{if(typeof WEB==="undefined")Object.assign(globalThis,{WEB:!NODE&&!CAPACITOR&&!TAURI&&typeof indexedDB==="object"});if(!WEB)return;class FilaWeb extends Fila{static keyva;constructor(...components){super(...components);FilaWeb.keyva||=new Keyva({name:"fila"})}async readText(){return await FilaWeb.keyva.get(this.path)}async readBinary(){const value=await FilaWeb.keyva.get(this.path);return value instanceof ArrayBuffer?value:(new TextEncoder).encode(value)}async readDirectory(){const filas=[];const range=Keyva.prefix(this.path+"/");const contents=await FilaWeb.keyva.each({range:range},"keys");for(const key of contents)if(typeof key==="string")filas.push(new Fila(key));return filas}async writeText(text,options){let current=this.up();const missingFolders=[];for(;;){if(await current.exists())break;missingFolders.push(current);if(current.up().path===current.path)break;current=current.up()}for(const folder of missingFolders)await folder.writeDirectory();if(options?.append)text=""+(await FilaWeb.keyva.get(this.path)||"")+text;await FilaWeb.keyva.set(this.path,text)}async writeBinary(arrayBuffer){await FilaWeb.keyva.set(this.path,arrayBuffer)}async writeDirectory(){if(await this.isDirectory())return;if(await this.exists())throw new Error("A file already exists at this location.");await FilaWeb.keyva.set(this.path,null)}async writeSymlink(at){throw new Error("Not implemented")}async delete(){if(await this.isDirectory()){const range=Keyva.prefix(this.path+"/");await FilaWeb.keyva.delete(range)}await FilaWeb.keyva.delete(this.path)}async move(target){throw new Error("Not implemented.")}async copy(target){throw new Error("Not implemented.")}watchProtected(recursive,callbackFn){throw new Error("Not implemented");return()=>{}}async rename(newName){throw new Error("Not implemented.")}async exists(){const value=await FilaWeb.keyva.get(this.path);return value!==undefined}async getSize(){return 0}async getModifiedTicks(){return 0}async getCreatedTicks(){return 0}async getAccessedTicks(){return 0}async isDirectory(){return await FilaWeb.keyva.get(this.path)===null}}Fila.setup(FilaWeb,"/","/","/__temp/")})();
