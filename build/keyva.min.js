"use strict";class Keyva{static unbound=IDBKeyRange.lowerBound(Number.MIN_SAFE_INTEGER);static prefix(prefix){return IDBKeyRange.bound(prefix,prefix+"ï¿¿")}static async each(){const databases=await indexedDB.databases();return databases.map((db=>db.name)).filter((s=>!!s&&s.startsWith(this.kvPrefix)))}static async delete(...names){names=names.length?names.map((n=>n.startsWith(this.kvPrefix)?n:this.kvPrefix+n)):await this.each();Promise.all(names.map((n=>this.asPromise(indexedDB.deleteDatabase(n)))))}static kvPrefix="-keyva-";constructor(options={}){const idx=options.indexes||[];this.indexes=(Array.isArray(idx)?idx:[idx]).sort();this.name=Keyva.kvPrefix+(options.name||"")}indexes;name;async get(k){const store=await this.getStore("readonly");return Array.isArray(k)?Promise.all(k.map((key=>Keyva.asPromise(store.get(key))))):Keyva.asPromise(store.get(k))}async each(options={},only){const store=await this.getStore("readonly");const target=options.index?store.index(options.index):store;const limit=options.limit;const range=options.range;if(only==="keys")return Keyva.asPromise(target.getAllKeys(range,limit));if(only==="values")return Keyva.asPromise(target.getAll(range,limit));let keys=[];let values=[];await Promise.allSettled([new Promise((async r=>{const results=await Keyva.asPromise(target.getAllKeys(range,limit));keys.push(...results);r()})),new Promise((async r=>{const results=await Keyva.asPromise(target.getAll(range,limit));values.push(...results);r()}))]);const tuples=[];for(let i=-1;++i<keys.length;)tuples.push([keys[i],values[i]]);return tuples}async set(a,b){const store=await this.getStore("readwrite");if(Array.isArray(a)){for(const entry of a)store.put(entry[1],entry[0]);return Keyva.asPromise(store.transaction)}store.put(b,a);return Keyva.asPromise(store.transaction)}async delete(arg){const store=await this.getStore("readwrite");arg??=Keyva.unbound;if(Array.isArray(arg)){for(const key of arg)store.delete(key)}else store.delete(arg);return Keyva.asPromise(store.transaction)}async getStore(mode){const db=await this.getDatabase();return db.transaction(this.name,mode).objectStore(this.name)}async getDatabase(){if(!this.database){await this.maybeFixSafari();let quit=false;let version;let indexNamesAdded=[];let indexNamesRemoved=[];for(;;){const request=indexedDB.open(this.name,version);request.onupgradeneeded=()=>{const db=request.result;const tx=request.transaction;const store=tx.objectStoreNames.contains(this.name)?tx.objectStore(this.name):db.createObjectStore(this.name);for(const index of indexNamesAdded)store.createIndex(index,index);for(const index of indexNamesRemoved)store.deleteIndex(index)};this.database=await Keyva.asPromise(request);if(quit)break;const tx=this.database.transaction(this.name,"readonly");const store=tx.objectStore(this.name);const indexNames=Array.from(store.indexNames).sort();tx.abort();indexNamesAdded=this.indexes.filter((n=>!indexNames.includes(n)));indexNamesRemoved=indexNames.filter((n=>!this.indexes.includes(n)));if(indexNamesAdded.length+indexNamesRemoved.length===0)break;quit=true;this.database.close();version=this.database.version+1}}return this.database}database=null;async maybeFixSafari(){if(!/Version\/14\.\d*\s*Safari\//.test(navigator.userAgent))return;let id=0;return new Promise((resolve=>{const hit=()=>indexedDB.databases().finally(resolve);id=setInterval(hit,50);hit()})).finally((()=>clearInterval(id)))}static asPromise(request){return new Promise(((resolve,reject)=>{request.oncomplete=request.onsuccess=()=>resolve(request.result);request.onabort=request.onerror=()=>reject(request.error)}))}}if(typeof module==="object")Object.assign(module.exports,{Keyva:Keyva});
